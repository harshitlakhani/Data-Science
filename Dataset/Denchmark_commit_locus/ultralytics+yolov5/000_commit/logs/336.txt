      updates 
         return self.cv4(self.act(self.bn(torch.cat((y1, y2), dim=1))))     class BottleneckCSPF(nn.Module):     def __init__(self, c1, c2, n=1, shortcut=False, g=1, e=0.5):  # ch_in, ch_out, number, shortcut, groups, expansion         super(BottleneckCSPF, self).__init__()         c_ = int(c2 * e)  # hidden channels         self.cv1 = Conv(c1, c_, 1, 1)         self.cv2 = nn.Conv2d(c1, c_, 1, 1, bias=False)         self.cv3 = nn.Conv2d(c_, c_, 1, 1, bias=False)         self.cv4 = Conv(c2, c2, 1, 1)         self.bn = nn.BatchNorm2d(2 * c_)  # applied to cat(cv2, cv3)         self.act = nn.LeakyReLU(0.1, inplace=True)         self.m = nn.Sequential(*[Bottleneck(c_, c_, shortcut, g, e=1.0) for _ in range(n)])      def forward(self, x):         y1 = self.cv3(self.m(self.cv1(x)))         y2 = self.cv2(x)         return self.cv4(self.act(self.bn(torch.cat((y1, y2), dim=1))))    class Narrow(nn.Module):      def __init__(self, c1, c2, shortcut=True, g=1):  # ch_in, ch_out, shortcut, groups          super(Narrow, self).__init__() 
