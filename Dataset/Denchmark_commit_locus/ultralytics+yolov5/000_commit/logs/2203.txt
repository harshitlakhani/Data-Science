      YOLOv5 Segmentation Dataloader Updates (#2188)          * Update C3 module          * Update C3 module          * Update C3 module          * Update C3 module          * update          * update          * update          * update          * update          * update          * update          * update          * update          * updates          * updates          * updates          * updates          * updates          * updates          * updates          * updates          * updates          * updates          * update          * update          * update          * update          * updates          * updates          * updates          * updates          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update datasets          * update          * update          * update          * update attempt_downlaod()          * merge          * merge          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * parameterize eps          * comments          * gs-multiple          * update          * max_nms implemented          * Create one_cycle() function          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * GitHub API rate limit fix          * update          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * astuple          * epochs          * update          * update          * ComputeLoss()          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * merge          * merge          * merge          * merge          * update          * update          * update          * update          * commit=tag == tags[-1]          * Update cudnn.benchmark          * update          * update          * update          * updates          * updates          * updates          * updates          * updates          * updates          * updates          * update          * update          * update          * update          * update          * mosaic9          * update          * update          * update          * update          * update          * update          * institute cache versioning          * only display on existing cache          * reverse cache exists booleans 
     # Transform label coordinates      n = len(targets)      if n:         # warp points         xy = np.ones((n * 4, 3))         xy[:, :2] = targets[:, [1, 2, 3, 4, 1, 4, 3, 2]].reshape(n * 4, 2)  # x1y1, x2y2, x1y2, x2y1         xy = xy @ M.T  # transform         if perspective:             xy = (xy[:, :2] / xy[:, 2:3]).reshape(n, 8)  # rescale         else:  # affine             xy = xy[:, :2].reshape(n, 8)          # create new boxes         x = xy[:, [0, 2, 4, 6]]         y = xy[:, [1, 3, 5, 7]]         xy = np.concatenate((x.min(1), y.min(1), x.max(1), y.max(1))).reshape(4, n).T          # # apply angle-based reduction of bounding boxes         # radians = a * math.pi / 180         # reduction = max(abs(math.sin(radians)), abs(math.cos(radians))) ** 0.5         # x = (xy[:, 2] + xy[:, 0]) / 2         # y = (xy[:, 3] + xy[:, 1]) / 2         # w = (xy[:, 2] - xy[:, 0]) * reduction         # h = (xy[:, 3] - xy[:, 1]) * reduction         # xy = np.concatenate((x - w / 2, y - h / 2, x + w / 2, y + h / 2)).reshape(4, n).T          # clip boxes         xy[:, [0, 2]] = xy[:, [0, 2]].clip(0, width)         xy[:, [1, 3]] = xy[:, [1, 3]].clip(0, height)         use_segments = any(x.any() for x in segments)         new = np.zeros((n, 4))         if use_segments:  # warp segments             segments = resample_segments(segments)  # upsample             for i, segment in enumerate(segments):                 xy = np.ones((len(segment), 3))                 xy[:, :2] = segment                 xy = xy @ M.T  # transform                 xy = xy[:, :2] / xy[:, 2:3] if perspective else xy[:, :2]  # perspective rescale or affine                  # clip                 new[i] = segment2box(xy, width, height)          else:  # warp boxes             xy = np.ones((n * 4, 3))             xy[:, :2] = targets[:, [1, 2, 3, 4, 1, 4, 3, 2]].reshape(n * 4, 2)  # x1y1, x2y2, x1y2, x2y1             xy = xy @ M.T  # transform             xy = (xy[:, :2] / xy[:, 2:3] if perspective else xy[:, :2]).reshape(n, 8)  # perspective rescale or affine              # create new boxes             x = xy[:, [0, 2, 4, 6]]             y = xy[:, [1, 3, 5, 7]]             new = np.concatenate((x.min(1), y.min(1), x.max(1), y.max(1))).reshape(4, n).T              # clip             new[:, [0, 2]] = new[:, [0, 2]].clip(0, width)             new[:, [1, 3]] = new[:, [1, 3]].clip(0, height)            # filter candidates         i = box_candidates(box1=targets[:, 1:5].T * s, box2=xy.T)         i = box_candidates(box1=targets[:, 1:5].T * s, box2=new.T, area_thr=0.01 if use_segments else 0.10)          targets = targets[i]         targets[:, 1:5] = xy[i]         targets[:, 1:5] = new[i]        return img, targets   
