      Add autoShape() speed profiling (#2459)          * Add autoShape() speed profiling          * Update common.py          * Create README.md          * Update hubconf.py          * cleanuip 
         x = np.stack(x, 0) if n > 1 else x[0][None]  # stack          x = np.ascontiguousarray(x.transpose((0, 3, 1, 2)))  # BHWC to BCHW          x = torch.from_numpy(x).to(p.device).type_as(p) / 255.  # uint8 to fp16/32         t.append(time_synchronized())            # Inference          with torch.no_grad():              y = self.model(x, augment, profile)[0]  # forward         y = non_max_suppression(y, conf_thres=self.conf, iou_thres=self.iou, classes=self.classes)  # NMS         t.append(time_synchronized())            # Post-process         y = non_max_suppression(y, conf_thres=self.conf, iou_thres=self.iou, classes=self.classes)  # NMS          for i in range(n):              scale_coords(shape1, y[i][:, :4], shape0[i])         t.append(time_synchronized())           return Detections(imgs, y, files, self.names)         return Detections(imgs, y, files, t, self.names, x.shape)      class Detections:      # detections class for YOLOv5 inference results     def __init__(self, imgs, pred, files, names=None):     def __init__(self, imgs, pred, files, times, names=None, shape=None):          super(Detections, self).__init__()          d = pred[0].device  # device          gn = [torch.tensor([*[im.shape[i] for i in [1, 0, 1, 0]], 1., 1.], device=d) for im in imgs]  # normalizations 
