      Update datasets.py (#494) 
         # h = (xy[:, 3] - xy[:, 1]) * reduction          # xy = np.concatenate((x - w / 2, y - h / 2, x + w / 2, y + h / 2)).reshape(4, n).T           # reject warped points outside of image         # clip boxes          xy[:, [0, 2]] = xy[:, [0, 2]].clip(0, width)          xy[:, [1, 3]] = xy[:, [1, 3]].clip(0, height)         w = xy[:, 2] - xy[:, 0]         h = xy[:, 3] - xy[:, 1]         area = w * h         area0 = (targets[:, 3] - targets[:, 1]) * (targets[:, 4] - targets[:, 2])         ar = np.maximum(w / (h + 1e-16), h / (w + 1e-16))  # aspect ratio         i = (w > 2) & (h > 2) & (area / (area0 * s + 1e-16) > 0.2) & (ar < 20)           # filter candidates         i = box_candidates(box1=targets[:, 1:5].T * s, box2=xy.T)          targets = targets[i]          targets[:, 1:5] = xy[i]        return img, targets     def box_candidates(box1, box2, wh_thr=2, ar_thr=20, area_thr=0.2):  # box1(4,n), box2(4,n)     # Compute candidate boxes: box1 before augment, box2 after augment, wh_thr (pixels), aspect_ratio_thr, area_ratio     w1, h1 = box1[2] - box1[0], box1[3] - box1[1]     w2, h2 = box2[2] - box2[0], box2[3] - box2[1]     ar = np.maximum(w2 / (h2 + 1e-16), h2 / (w2 + 1e-16))  # aspect ratio     return (w2 > wh_thr) & (h2 > wh_thr) & (w2 * h2 / (w1 * h1 + 1e-16) > area_thr) & (ar < ar_thr)  # candidates    def cutout(image, labels):     # https://arxiv.org/abs/1708.04552     # https://github.com/hysts/pytorch_cutout/blob/master/dataloader.py     # https://towardsdatascience.com/when-conventional-wisdom-fails-revisiting-data-augmentation-for-self-driving-cars-4831998c5509     # Applies image cutout augmentation https://arxiv.org/abs/1708.04552      h, w = image.shape[:2]        def bbox_ioa(box1, box2): 
