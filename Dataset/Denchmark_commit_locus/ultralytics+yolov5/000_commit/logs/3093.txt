      Add `train.run()` method (#3700)          * Update train.py explicit arguments          * Update train.py          * Add run method 
     # Trainloader      dataloader, dataset = create_dataloader(train_path, imgsz, batch_size // WORLD_SIZE, gs, single_cls,                                              hyp=hyp, augment=True, cache=opt.cache_images, rect=opt.rect, rank=RANK,                                             workers=opt.workers,                                             workers=workers,                                              image_weights=opt.image_weights, quad=opt.quad, prefix=colorstr('train: '))      mlc = np.concatenate(dataset.labels, 0)[:, 0].max()  # max label class      nb = len(dataloader)  # number of batches     assert mlc < nc, 'Label class %g exceeds nc=%g in %s. Possible class labels are 0-%g' % (mlc, nc, opt.data, nc - 1)     assert mlc < nc, 'Label class %g exceeds nc=%g in %s. Possible class labels are 0-%g' % (mlc, nc, data, nc - 1)        # Process 0      if RANK in [-1, 0]:          testloader = create_dataloader(test_path, imgsz_test, batch_size // WORLD_SIZE * 2, gs, single_cls,                                        hyp=hyp, cache=opt.cache_images and not opt.notest, rect=True, rank=-1,                                        workers=opt.workers,                                        hyp=hyp, cache=opt.cache_images and not notest, rect=True, rank=-1,                                        workers=workers,                                         pad=0.5, prefix=colorstr('val: '))[0]           if not opt.resume:         if not resume:              labels = np.concatenate(dataset.labels, 0)              c = torch.tensor(labels[:, 0])  # classes              # cf = torch.bincount(c.long(), minlength=nc) + 1.  # frequency 
