      Label caching foundational re-write #306 
                 gb += self.imgs[i].nbytes                  pbar.desc = 'Caching images (%.1fGB)' % (gb / 1E9)           # Detect corrupted images https://medium.com/joelthchao/programmatically-detect-corrupted-image-8c1b2006c3d3         detect_corrupted_images = False         if detect_corrupted_images:             from skimage import io  # conda install -c conda-forge scikit-image             for file in tqdm(self.img_files, desc='Detecting corrupted images'):                 try:                     _ = io.imread(file)                 except:                     print('Corrupted image detected: %s' % file)     def cache_labels(self, path='labels.cache'):         # Cache dataset labels, check images and read shapes         x = {}  # dict         pbar = tqdm(zip(self.img_files, self.label_files), desc='Scanning images', total=len(self.img_files))         for (img, label) in pbar:             try:                 l = []                 image = Image.open(img)                 image.verify()  # PIL verify                 # _ = io.imread(img)  # skimage verify (from skimage import io)                 shape = exif_size(image)  # image size                 if os.path.isfile(label):                     with open(label, 'r') as f:                         l = np.array([x.split() for x in f.read().splitlines()], dtype=np.float32)  # labels                 if len(l) == 0:                     l = np.zeros((0, 5), dtype=np.float32)                 x[img] = [l, shape]             except Exception as e:                 x[img] = None                 print('WARNING: %s: %s' % (img, e))          x['hash'] = get_hash(self.label_files + self.img_files)         torch.save(x, path)  # save for next time         return x        def __len__(self):          return len(self.img_files) 
