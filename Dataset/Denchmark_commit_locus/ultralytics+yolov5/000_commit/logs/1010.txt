      Label caching foundational re-write #306 
             self.batch_shapes = np.ceil(np.array(shapes) * img_size / stride + pad).astype(np.int) * stride            # Cache labels         self.imgs = [None] * n         self.labels = [np.zeros((0, 5), dtype=np.float32)] * n          create_datasubset, extract_bounding_boxes, labels_loaded = False, False, False          nm, nf, ne, ns, nd = 0, 0, 0, 0, 0  # number missing, found, empty, datasubset, duplicate         np_labels_path = str(Path(self.label_files[0]).parent) + '.npy'  # saved labels in *.npy file         if os.path.isfile(np_labels_path):             s = np_labels_path  # print string             x = np.load(np_labels_path, allow_pickle=True)             if len(x) == n:                 self.labels = x                 labels_loaded = True         else:             s = path.replace('images', 'labels')           pbar = tqdm(self.label_files)          for i, file in enumerate(pbar):             if labels_loaded:                 l = self.labels[i]                 # np.savetxt(file, l, '%g')  # save *.txt from *.npy file             else:                 try:                     with open(file, 'r') as f:                         l = np.array([x.split() for x in f.read().splitlines()], dtype=np.float32)                 except:                     nm += 1  # print('missing labels for image %s' % self.img_files[i])  # file missing                     continue              l = self.labels[i]  # label              if l.shape[0]:                  assert l.shape[1] == 5, '> 5 label columns: %s' % file                  assert (l >= 0).all(), 'negative labels: %s' % file 
