      module updates 
         return self.cv4(self.act(self.bn(torch.cat((y1, y2), dim=1))))     class Narrow(nn.Module):     def __init__(self, c1, c2, shortcut=True, g=1):  # ch_in, ch_out, shortcut, groups         super(Narrow, self).__init__()         c_ = c2 // 2  # hidden channels         self.cv1 = Conv(c1, c_, 1, 1)         self.cv2 = Conv(c_, c2, 3, 1, g=g)         self.add = shortcut and c1 == c2      def forward(self, x):         return x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))   class Origami(nn.Module):  # 5-side layering     def forward(self, x):         y = F.pad(x, [1, 1, 1, 1])         return torch.cat([x, y[..., :-2, 1:-1], y[..., 1:-1, :-2], y[..., 2:, 1:-1], y[..., 1:-1, 2:]], 1)   class ConvPlus(nn.Module):  # standard convolution class ConvPlus(nn.Module):     # Plus-shaped convolution      def __init__(self, c1, c2, k=3, s=1, g=1, bias=True):  # ch_in, ch_out, kernel, stride, groups          super(ConvPlus, self).__init__()          self.cv1 = nn.Conv2d(c1, c2, (k, 1), s, (k // 2, 0), groups=g, bias=bias) 
