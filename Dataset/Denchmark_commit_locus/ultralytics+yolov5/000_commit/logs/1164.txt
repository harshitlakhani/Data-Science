      Precision-Recall Curve Feature Addition (#1107)          * initial commit          * Update general.py          Indent update          * Update general.py          refactor duplicate code          * 200 dpi 
             p[ci] = np.interp(-pr_score, -conf[i], precision[:, 0])  # p at pr_score                # AP from recall-precision curve             py.append(np.interp(px, recall[:, 0], precision[:, 0]))  # precision at mAP@0.5              for j in range(tp.shape[1]):                  ap[ci, j] = compute_ap(recall[:, j], precision[:, j])               # Plot             # fig, ax = plt.subplots(1, 1, figsize=(5, 5))             # ax.plot(recall, precision)             # ax.set_xlabel('Recall')             # ax.set_ylabel('Precision')             # ax.set_xlim(0, 1.01)             # ax.set_ylim(0, 1.01)             # fig.tight_layout()             # fig.savefig('PR_curve.png', dpi=300)       # Compute F1 score (harmonic mean of precision and recall)      f1 = 2 * p * r / (p + r + 1e-16)       if plot:         py = np.stack(py, axis=1)         fig, ax = plt.subplots(1, 1, figsize=(5, 5))         ax.plot(px, py, linewidth=0.5, color='grey')  # plot(recall, precision)         ax.plot(px, py.mean(1), linewidth=2, color='blue', label='all classes')         ax.set_xlabel('Recall')         ax.set_ylabel('Precision')         ax.set_xlim(0, 1)         ax.set_ylim(0, 1)         plt.legend()         fig.tight_layout()         fig.savefig(fname, dpi=200)       return p, r, ap, f1, unique_classes.astype('int32')     
