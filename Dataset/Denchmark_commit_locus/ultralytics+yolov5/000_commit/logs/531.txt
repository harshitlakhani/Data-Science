      Use multi-threading in cache_labels (#3505)          * Use multi threading in cache_labels          * PEP8 reformat          * Add num_threads          * changed ThreadPool.imap_unordered to Pool.imap_unordered          * Remove inplace additions          * Update datasets.py          refactor initial desc          Co-authored-by: Glenn Jocher <glenn.jocher@ultralytics.com> 
         if not annotated_only or Path(img2label_paths([str(img)])[0]).exists():  # check label              with open(path / txt[i], 'a') as f:                  f.write(str(img) + '\n')  # add image to txt file   def verify_image_label(params):     # Verify one image-label pair     im_file, lb_file, prefix = params     nm, nf, ne, nc = 0, 0, 0, 0  # number missing, found, empty, corrupt     try:         # verify images         im = Image.open(im_file)         im.verify()  # PIL verify         shape = exif_size(im)  # image size         segments = []  # instance segments         assert (shape[0] > 9) & (shape[1] > 9), f'image size {shape} <10 pixels'         assert im.format.lower() in img_formats, f'invalid image format {im.format}'          # verify labels         if os.path.isfile(lb_file):             nf = 1  # label found             with open(lb_file, 'r') as f:                 l = [x.split() for x in f.read().strip().splitlines() if len(x)]                 if any([len(x) > 8 for x in l]):  # is segment                     classes = np.array([x[0] for x in l], dtype=np.float32)                     segments = [np.array(x[1:], dtype=np.float32).reshape(-1, 2) for x in l]  # (cls, xy1...)                     l = np.concatenate((classes.reshape(-1, 1), segments2boxes(segments)), 1)  # (cls, xywh)                 l = np.array(l, dtype=np.float32)             if len(l):                 assert l.shape[1] == 5, 'labels require 5 columns each'                 assert (l >= 0).all(), 'negative labels'                 assert (l[:, 1:] <= 1).all(), 'non-normalized or out of bounds coordinate labels'                 assert np.unique(l, axis=0).shape[0] == l.shape[0], 'duplicate labels'             else:                 ne = 1  # label empty                 l = np.zeros((0, 5), dtype=np.float32)         else:             nm = 1  # label missing             l = np.zeros((0, 5), dtype=np.float32)         return im_file, l, shape, segments, nm, nf, ne, nc     except Exception as e:         nc = 1         logging.info(f'{prefix}WARNING: Ignoring corrupted image and/or label {im_file}: {e}')         return [None] * 4 + [nm, nf, ne, nc] 
