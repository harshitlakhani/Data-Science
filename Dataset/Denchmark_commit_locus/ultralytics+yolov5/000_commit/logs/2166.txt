      update build_targets() (#589)          Signed-off-by: Glenn Jocher <glenn.jocher@ultralytics.com> 
   def build_targets(p, targets, model):      # Build targets for compute_loss(), input targets(image,class,x,y,w,h)     det = model.module.model[-1] if type(model) in (nn.parallel.DataParallel, nn.parallel.DistributedDataParallel) \         else model.model[-1]  # Detect() module     det = model.module.model[-1] if torch_utils.is_parallel(model) else model.model[-1]  # Detect() module      na, nt = det.na, targets.shape[0]  # number of anchors, targets      tcls, tbox, indices, anch = [], [], [], []     gain = torch.ones(6, device=targets.device)  # normalized to gridspace gain     off = torch.tensor([[1, 0], [0, 1], [-1, 0], [0, -1]], device=targets.device).float()  # overlap offsets     at = torch.arange(na).view(na, 1).repeat(1, nt)  # anchor tensor, same as .repeat_interleave(nt)     gain = torch.ones(7, device=targets.device)  # normalized to gridspace gain     ai = torch.arange(na, device=targets.device).float().view(na, 1).repeat(1, nt)  # same as .repeat_interleave(nt)     targets = torch.cat((targets.repeat(na, 1, 1), ai[:, :, None]), 2)  # append anchor indices      g = 0.5  # bias     off = torch.tensor([[0, 0],                         [1, 0], [0, 1], [-1, 0], [0, -1],  # j,k,l,m                         # [1, 1], [1, -1], [-1, 1], [-1, -1],  # jk,jm,lk,lm                         ], device=targets.device).float() * g  # offsets       g = 0.5  # offset     style = 'rect4'      for i in range(det.nl):          anchors = det.anchors[i]         gain[2:] = torch.tensor(p[i].shape)[[3, 2, 3, 2]]  # xyxy gain         gain[2:6] = torch.tensor(p[i].shape)[[3, 2, 3, 2]]  # xyxy gain            # Match targets to anchors         a, t, offsets = [], targets * gain, 0         t, offsets = targets * gain, 0          if nt:             r = t[None, :, 4:6] / anchors[:, None]  # wh ratio             # Matches             r = t[:, :, 4:6] / anchors[:, None]  # wh ratio              j = torch.max(r, 1. / r).max(2)[0] < model.hyp['anchor_t']  # compare             # j = wh_iou(anchors, t[:, 4:6]) > model.hyp['iou_t']  # iou(3,n) = wh_iou(anchors(3,2), gwh(n,2))             a, t = at[j], t.repeat(na, 1, 1)[j]  # filter             # j = wh_iou(anchors, t[:, 4:6]) > model.hyp['iou_t']  # iou(3,n)=wh_iou(anchors(3,2), gwh(n,2))             t = t[j]  # filter               # overlaps             # Offsets              gxy = t[:, 2:4]  # grid xy             z = torch.zeros_like(gxy)             if style == 'rect2':                 j, k = ((gxy % 1. < g) & (gxy > 1.)).T                 a, t = torch.cat((a, a[j], a[k]), 0), torch.cat((t, t[j], t[k]), 0)                 offsets = torch.cat((z, z[j] + off[0], z[k] + off[1]), 0) * g             elif style == 'rect4':                 j, k = ((gxy % 1. < g) & (gxy > 1.)).T                 l, m = ((gxy % 1. > (1 - g)) & (gxy < (gain[[2, 3]] - 1.))).T                 a, t = torch.cat((a, a[j], a[k], a[l], a[m]), 0), torch.cat((t, t[j], t[k], t[l], t[m]), 0)                 offsets = torch.cat((z, z[j] + off[0], z[k] + off[1], z[l] + off[2], z[m] + off[3]), 0) * g             gxi = gain[[2, 3]] - gxy  # inverse             j, k = ((gxy % 1. < g) & (gxy > 1.)).T             l, m = ((gxi % 1. < g) & (gxi > 1.)).T             j = torch.stack((torch.ones_like(j), j, k, l, m))             t = t.repeat((5, 1, 1))[j]             offsets = (torch.zeros_like(gxy)[None] + off[:, None])[j]            # Define          b, c = t[:, :2].long().T  # image, class 
