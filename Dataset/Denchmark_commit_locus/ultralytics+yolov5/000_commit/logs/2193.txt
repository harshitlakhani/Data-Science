      YOLOv5 Segmentation Dataloader Updates (#2188)          * Update C3 module          * Update C3 module          * Update C3 module          * Update C3 module          * update          * update          * update          * update          * update          * update          * update          * update          * update          * updates          * updates          * updates          * updates          * updates          * updates          * updates          * updates          * updates          * updates          * update          * update          * update          * update          * updates          * updates          * updates          * updates          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update datasets          * update          * update          * update          * update attempt_downlaod()          * merge          * merge          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * parameterize eps          * comments          * gs-multiple          * update          * max_nms implemented          * Create one_cycle() function          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * GitHub API rate limit fix          * update          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * ComputeLoss          * astuple          * epochs          * update          * update          * ComputeLoss()          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * update          * merge          * merge          * merge          * merge          * update          * update          * update          * update          * commit=tag == tags[-1]          * Update cudnn.benchmark          * update          * update          * update          * updates          * updates          * updates          * updates          * updates          * updates          * updates          * update          * update          * update          * update          * update          * mosaic9          * update          * update          * update          * update          * update          * update          * institute cache versioning          * only display on existing cache          * reverse cache exists booleans 
         self.label_files = img2label_paths(self.img_files)  # labels          cache_path = (p if p.is_file() else Path(self.label_files[0]).parent).with_suffix('.cache')  # cached labels          if cache_path.is_file():             cache = torch.load(cache_path)  # load             if cache['hash'] != get_hash(self.label_files + self.img_files) or 'results' not in cache:  # changed                 cache = self.cache_labels(cache_path, prefix)  # re-cache             cache, exists = torch.load(cache_path), True  # load             if cache['hash'] != get_hash(self.label_files + self.img_files) or 'version' not in cache:  # changed                 cache, exists = self.cache_labels(cache_path, prefix), False  # re-cache          else:             cache = self.cache_labels(cache_path, prefix)  # cache             cache, exists = self.cache_labels(cache_path, prefix), False  # cache            # Display cache         [nf, nm, ne, nc, n] = cache.pop('results')  # found, missing, empty, corrupted, total         desc = f"Scanning '{cache_path}' for images and labels... {nf} found, {nm} missing, {ne} empty, {nc} corrupted"         tqdm(None, desc=prefix + desc, total=n, initial=n)         nf, nm, ne, nc, n = cache.pop('results')  # found, missing, empty, corrupted, total         if exists:             d = f"Scanning '{cache_path}' for images and labels... {nf} found, {nm} missing, {ne} empty, {nc} corrupted"             tqdm(None, desc=prefix + d, total=n, initial=n)  # display cache results          assert nf > 0 or not augment, f'{prefix}No labels in {cache_path}. Can not train without labels. See {help_url}'            # Read cache          cache.pop('hash')  # remove hash         labels, shapes = zip(*cache.values())         cache.pop('version')  # remove version         labels, shapes, self.segments = zip(*cache.values())          self.labels = list(labels)          self.shapes = np.array(shapes, dtype=np.float64)          self.img_files = list(cache.keys())  # update 
