      updates 
     google_utils.attempt_download(weights)      start_epoch, best_fitness = 0, 0.0      if weights.endswith('.pt'):  # pytorch format         chkpt = torch.load(weights, map_location=device)         ckpt = torch.load(weights, map_location=device)  # load checkpoint            # load model          try:             chkpt['model'] = \                 {k: v for k, v in chkpt['model'].state_dict().items() if model.state_dict()[k].numel() == v.numel()}             model.load_state_dict(chkpt['model'], strict=False)             ckpt['model'] = \                 {k: v for k, v in ckpt['model'].state_dict().items() if model.state_dict()[k].numel() == v.numel()}             model.load_state_dict(ckpt['model'], strict=False)          except KeyError as e:              s = "%s is not compatible with %s. Specify --weights '' or specify a --cfg compatible with %s." \                  % (opt.weights, opt.cfg, opt.weights)              raise KeyError(s) from e            # load optimizer         if chkpt['optimizer'] is not None:             optimizer.load_state_dict(chkpt['optimizer'])             best_fitness = chkpt['best_fitness']         if ckpt['optimizer'] is not None:             optimizer.load_state_dict(ckpt['optimizer'])             best_fitness = ckpt['best_fitness']            # load results         if chkpt.get('training_results') is not None:         if ckpt.get('training_results') is not None:              with open(results_file, 'w') as file:                 file.write(chkpt['training_results'])  # write results.txt                 file.write(ckpt['training_results'])  # write results.txt           start_epoch = chkpt['epoch'] + 1         del chkpt         start_epoch = ckpt['epoch'] + 1         del ckpt        # Mixed precision training https://github.com/NVIDIA/apex      if mixed_precision: 
