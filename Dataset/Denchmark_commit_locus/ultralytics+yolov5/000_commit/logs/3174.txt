      module updates 
         return x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))     class BottleneckLight(nn.Module):     def __init__(self, c1, c2, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, shortcut, groups, expansion         super(BottleneckLight, self).__init__()         c_ = int(c2 * e)  # hidden channels         self.cv1 = Conv(c1, c_, 1, 1)         self.cv2 = nn.Conv2d(c_, c2, 3, 1, 3 // 2, groups=g, bias=False)         self.bn = nn.BatchNorm2d(c2)         self.act = nn.LeakyReLU(0.1, inplace=True)         self.add = shortcut and c1 == c2      def forward(self, x):         return self.act(self.bn(x + self.cv2(self.cv1(x)) if self.add else self.cv2(self.cv1(x))))    class BottleneckCSP(nn.Module):     # CSP Bottleneck https://github.com/WongKinYiu/CrossStagePartialNetworks      def __init__(self, c1, c2, n=1, shortcut=True, g=1, e=0.5):  # ch_in, ch_out, number, shortcut, groups, expansion          super(BottleneckCSP, self).__init__()          c_ = int(c2 * e)  # hidden channels 
