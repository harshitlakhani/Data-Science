      AutoAnchor implementation 
         Usage:              from utils.utils import *; _ = kmean_anchors()      """     thr = 1. / thr      def metric(k):  # compute metrics         r = wh[:, None] / k[None]         x = torch.min(r, 1. / r).min(2)[0]  # ratio metric         # x = wh_iou(wh, torch.tensor(k))  # iou metric         return x, x.max(1)[0]  # x, best_x       from utils.datasets import LoadImagesAndLabels     def fitness(k):  # mutation fitness         _, best = metric(k)         return (best * (best > thr).float()).mean()  # fitness        def print_results(k):          k = k[np.argsort(k.prod(1))]  # sort small to large         iou = wh_iou(wh, torch.Tensor(k))         max_iou = iou.max(1)[0]         bpr, aat = (max_iou > thr).float().mean(), (iou > thr).float().mean() * n  # best possible recall, anch > thr          # thr = 5.0         # r = wh[:, None] / k[None]         # ar = torch.max(r, 1. / r).max(2)[0]         # max_ar = ar.min(1)[0]         # bpr, aat = (max_ar < thr).float().mean(), (ar < thr).float().mean() * n  # best possible recall, anch > thr          print('%.2f iou_thr: %.3f best possible recall, %.2f anchors > thr' % (thr, bpr, aat))         print('n=%g, img_size=%s, IoU_all=%.3f/%.3f-mean/best, IoU>thr=%.3f-mean: ' %               (n, img_size, iou.mean(), max_iou.mean(), iou[iou > thr].mean()), end='')         x, best = metric(k)         bpr, aat = (best > thr).float().mean(), (x > thr).float().mean() * n  # best possible recall, anch > thr         print('thr=%.2f: %.3f best possible recall, %.2f anchors past thr' % (thr, bpr, aat))         print('n=%g, img_size=%s, metric_all=%.3f/%.3f-mean/best, past_thr=%.3f-mean: ' %               (n, img_size, x.mean(), best.mean(), x[x > thr].mean()), end='')          for i, x in enumerate(k):              print('%i,%i' % (round(x[0]), round(x[1])), end=',  ' if i < len(k) - 1 else '\n')  # use in *.cfg          return k       def fitness(k):  # mutation fitness         iou = wh_iou(wh, torch.Tensor(k))  # iou         max_iou = iou.max(1)[0]         return (max_iou * (max_iou > thr).float()).mean()  # product      # def fitness_ratio(k):  # mutation fitness     #     # wh(5316,2), k(9,2)     #     r = wh[:, None] / k[None]     #     x = torch.max(r, 1. / r).max(2)[0]     #     m = x.min(1)[0]     #     return 1. / (m * (m < 5).float()).mean()  # product     if isinstance(path, str):  # *.yaml file         with open(path) as f:             data_dict = yaml.load(f, Loader=yaml.FullLoader)  # model dict         from utils.datasets import LoadImagesAndLabels         dataset = LoadImagesAndLabels(data_dict['train'], augment=True, rect=True)     else:         dataset = path  # dataset        # Get label wh     wh = []     with open(path) as f:         data_dict = yaml.load(f, Loader=yaml.FullLoader)  # model dict     dataset = LoadImagesAndLabels(data_dict['train'], augment=True, rect=True)     nr = 1 if img_size[0] == img_size[1] else 3  # number augmentation repetitions     for s, l in zip(dataset.shapes, dataset.labels):         # wh.append(l[:, 3:5] * (s / s.max()))  # image normalized to letterbox normalized wh         wh.append(l[:, 3:5] * s)  # image normalized to pixels     wh = np.concatenate(wh, 0).repeat(nr, axis=0)  # augment 3x     # wh *= np.random.uniform(img_size[0], img_size[1], size=(wh.shape[0], 1))  # normalized to pixels (multi-scale)     wh = wh[(wh > 2.0).all(1)]  # remove below threshold boxes (< 2 pixels wh)     shapes = img_size * dataset.shapes / dataset.shapes.max(1, keepdims=True)     wh = torch.tensor(np.concatenate([l[:, 3:5] * s for s, l in zip(shapes, dataset.labels)])).float()  # wh     wh = wh[(wh > 2.0).all(1)].numpy()  # filter > 2 pixels        # Kmeans calculation      from scipy.cluster.vq import kmeans 
