      Update caching (#1496) 
         shutil.copyfile(file, new_path / Path(file).name)     def extract_boxes(path='../coco128/'):  # from utils.datasets import *; extract_boxes('../coco128')     # Convert detection dataset into classification dataset, with one directory per class      path = Path(path)  # images dir     shutil.rmtree(path / 'classifier') if (path / 'classifier').is_dir() else None  # remove existing     files = list(path.rglob('*.*'))     n = len(files)  # number of files     for im_file in tqdm(files, total=n):         if im_file.suffix[1:] in img_formats:             # image             im = cv2.imread(str(im_file))[..., ::-1]  # BGR to RGB             h, w = im.shape[:2]              # labels             lb_file = Path(img2label_paths([str(im_file)])[0])             if Path(lb_file).exists():                 with open(lb_file, 'r') as f:                     lb = np.array([x.split() for x in f.read().splitlines()], dtype=np.float32)  # labels                  for j, x in enumerate(lb):                     c = int(x[0])  # class                     f = (path / 'classifier') / f'{c}' / f'{path.stem}_{im_file.stem}_{j}.jpg'  # new filename                     if not f.parent.is_dir():                         f.parent.mkdir(parents=True)                      b = x[1:] * [w, h, w, h]  # box                     # b[2:] = b[2:].max()  # rectangle to square                     b[2:] = b[2:] * 1.2 + 3  # pad                     b = xywh2xyxy(b.reshape(-1, 4)).ravel().astype(np.int)                      b[[0, 2]] = np.clip(b[[0, 2]], 0, w)  # clip boxes outside of image                     b[[1, 3]] = np.clip(b[[1, 3]], 0, h)                     assert cv2.imwrite(str(f), im[b[1]:b[3], b[0]:b[2]]), f'box failure in {f}'    def autosplit(path='../coco128', weights=(0.9, 0.1, 0.0)):  # from utils.datasets import *; autosplit('../coco128')      """ Autosplit a dataset into train/val/test splits and save path/autosplit_*.txt files      # Arguments 
